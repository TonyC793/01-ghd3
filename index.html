<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta viewport="width=device-width, initial-scale=1.0">
  <title>Data Visualization</title>
  <style>
    body {
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #f3f3f3;
    }
    svg {
      border: 1px solid #ccc;
    }
    .handwriting {
      font-family: 'Brush Script MT', cursive;
      font-size: 24px;
      fill: black;
    }
  </style>
</head>
<body>
  <svg width="800" height="600"></svg>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <script>
    // SVG setup
    const svgWidth = 800, svgHeight = 600;
    const svg = d3.select('svg');

    // Text settings
    const text1 = "All work and no play makes Jack a dull boy";
    const text2 = "All play and no work makes Bob a play boy";

    // Add texts
    svg.append('text')
      .attr('x', 100)
      .attr('y', 50)
      .text(text1)
      .attr('class', 'handwriting');

    svg.append('text')
      .attr('x', 100)
      .attr('y', 80)
      .text(text2)
      .attr('class', 'handwriting');

    // Child settings
    const childRadius = 20;
    const childPosition = { x: 100, y: svgHeight - 100 };

    // Tree settings
    const treeWidth = 50;
    const treeHeight = 150;
    const treePosition = { x: svgWidth - 250, y: svgHeight - treeHeight - 150 };

    // Canopy settings (Hexagon)
    const canopySideLength = 70;
    const canopyHeight = Math.sqrt(3) * canopySideLength / 2;
    const canopyCenter = { x: treePosition.x + treeWidth / 2, y: treePosition.y - canopyHeight / 2 };

    // Apple settings
    const appleRadius = 10;
    const applePosition = { x: canopyCenter.x - canopySideLength / 3, y: canopyCenter.y };

    // Arrow settings
    const arrowLength = 80;
    const arrowPosition = { x: childPosition.x + 40, y: childPosition.y };

    // Draw child
    svg.append('circle')
      .attr('cx', childPosition.x)
      .attr('cy', childPosition.y)
      .attr('r', childRadius)
      .style('fill', 'blue');

    // Draw tree
    svg.append('rect')
      .attr('x', treePosition.x)
      .attr('y', treePosition.y)
      .attr('width', treeWidth)
      .attr('height', treeHeight)
      .style('fill', 'brown');

    // Draw canopy
    const canopyPoints = [
      [canopyCenter.x - canopySideLength, canopyCenter.y],
      [canopyCenter.x - canopySideLength / 2, canopyCenter.y - canopyHeight],
      [canopyCenter.x + canopySideLength / 2, canopyCenter.y - canopyHeight],
      [canopyCenter.x + canopySideLength, canopyCenter.y],
      [canopyCenter.x + canopySideLength / 2, canopyCenter.y + canopyHeight],
      [canopyCenter.x - canopySideLength / 2, canopyCenter.y + canopyHeight]
    ].map(p => p.join(',')).join(' ');

    svg.append('polygon')
      .attr('points', canopyPoints)
      .style('fill', 'green');

    // Draw apple
    svg.append('circle')
      .attr('cx', applePosition.x)
      .attr('cy', applePosition.y)
      .attr('r', appleRadius)
      .style('fill', 'red');

    // Draw arrow
    svg.append('line')
      .attr('x1', arrowPosition.x)
      .attr('y1', arrowPosition.y)
      .attr('x2', arrowPosition.x + arrowLength)
      .attr('y2', arrowPosition.y)
      .attr('stroke-width', 2)
      .style('stroke', 'black');

    // Gravity force
    const gravity = 0.98;

    // Arrow dynamics
    let isArrowShot = false;
    let arrowVelocity = { x: 5, y: -10 };

    // d3-force setup
    const simulation = d3.forceSimulation()
        .force('x', d3.forceX().strength(0.02))
        .force('y', d3.forceY().strength(0.02))
        .on('tick', ticked);

    function ticked() {
        if (isArrowShot) {
            arrow.attr('x1', d => d.x += arrowVelocity.x)
                .attr('y1', d => d.y += arrowVelocity.y)
                .attr('x2', d => d.x + arrowLength)
                .attr('y2', d => d.y);
            
            arrowTip.attr('d', d3.line()([[d.x + arrowLength, d.y - 5], [d.x + arrowLength + 10, d.y], [d.x + arrowLength, d.y + 5]]));
        

            arrowVelocity.y += gravity; // Apply gravity to arrow

            // Check for collision with apple
            if (checkCollision(arrow, apple)) {
                // Handle collision - make apple fall
                apple.attr('cy', d => d.y += gravity);
            }
        }
    }

    const drag = d3.drag()
    .on('start', dragStarted)
    .on('drag', dragging)
    .on('end', dragEnded);

    function dragStarted(event, d) {
        d3.select(this).raise();
    }

    function dragging(event, d) {
        const dx = event.x - d.x;
        const dy = event.y - d.y;
        const angle = Math.atan2(dy, dx);
        arrow.attr('transform', `rotate(${angle * 180 / Math.PI},${d.x},${d.y})`);
        arrowTip.attr('transform', `rotate(${angle * 180 / Math.PI},${d.x},${d.y})`);
    }

    function dragEnded(event, d) {
        // Update arrow velocity based on drag
        arrowVelocity = { x: Math.cos(angle) * 5, y: Math.sin(angle) * -10 };
    }

    // Apply drag behavior to the arrow
    arrow.call(drag);
    arrowTip.call(drag);


    // Interactivity - shoot arrow on click
    svg.on('click', () => {
        if (!isArrowShot) {
            isArrowShot = true;
            simulation.nodes([arrowStartPosition]);
        }
    });

    // Collision detection function
    function checkCollision(arrow, apple) {
        // Simple collision detection logic (can be improved)
        const arrowPos = { x: arrow.attr('x1'), y: arrow.attr('y1') };
        const applePos = { x: apple.attr('cx'), y: apple.attr('cy') };

        const distance = Math.sqrt(Math.pow(arrowPos.x - applePos.x, 2) + Math.pow(arrowPos.y - applePos.y, 2));
        return distance < appleRadius;
    }

    // Start simulation
    simulation.nodes([arrowStartPosition, applePosition]);


  </script>
</body>
</html>
